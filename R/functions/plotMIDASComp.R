#############################################################
# plotMIDASlist.R
# Adrian C
#
# Plots the output of readMIDASExcel. Loosely based on 
# plotCNOlist from the CellNOptR package.
#
# Arguments:
#   - MIDASlist: MIDAS list generated by readMIDASExcel
#   - dataWidth: Relative width of the data compared to the cues, optional
#
# Depndencies: tidyr, dplyr, ggplot2, cowplot
#############################################################

gatherMIDASlist <- function(MIDASlist) {
  data <- data.frame(cueNum=numeric(), time=numeric(), signal=character(), value=numeric(), variance=numeric())
  for (i in 1:length(MIDASlist$timeSignals)) {
    # Get the values an gather them
    timeValues <- as.data.frame(MIDASlist$valueSignals[,,i]) # Get data values
    timeValues <- cbind(timeValues, 1:nrow(timeValues)) # Add column to keep track of the cue combination
    colnames(timeValues) <- c(MIDASlist$namesSignals, "cueNum") # Set column names
    timeValues <- gather(timeValues, "signal", "value", -cueNum)
    
    # Do the same as above for variances
    timeVariances <- as.data.frame(MIDASlist$valueVariances[,,i]) # Get data variances
    timeVariances <- cbind(timeVariances, 1:nrow(timeVariances)) # Add column to keep track of the cue combination
    colnames(timeVariances) <- c(MIDASlist$namesSignals, "cueNum") # Set column names
    timeVariances <- gather(timeVariances, "signal", "variance", -cueNum)
    
    # Merge timeVariances and timeValues
    merged <- merge(timeVariances, timeValues)
    
    # Set the time column
    merged$time <- MIDASlist$timeSignals[i]
    
    # Append data to the original df
    data <- rbind(data, merged)
  }
  
  return(data)
}

plotMIDASComp <- function(MIDASlist1, MIDASlist2, dataWidth = NA) {
  # First we must do some processing to put the MIDASlist data into a format that can be plotted (key-value-ish)
  data1 <- gatherMIDASlist(MIDASlist1)
  data2 <- gatherMIDASlist(MIDASlist2)
  allData <- rbind(data1, data2)
  
  # Remove NA values - this causes weird behavior, don't do it
  # data <- data[!is.na(data$value),]
  
  # Also process the cues data
  cues <- as.data.frame(MIDASlist1$valueCues)
  colnames(cues) <- MIDASlist1$namesCues
  cues$cueNum <- 1:nrow(cues)
  cuesGather <- gather(cues, "cue", "value", -cueNum)
  cuesGather$value[cuesGather$value == 0] <- "None" # Set all zeroes to None
  for (cue in MIDASlist1$namesCues) { # Set cues to their types
    cuesGather$value[cuesGather$cue == cue & cuesGather$value == 1] <- MIDASlist1$treatmentDefs$type[MIDASlist1$treatmentDefs$name == cue]
  }
  cuesGather$value <- factor(cuesGather$value)
  
  # Check which panels will have no data in them and make a new df with that info
  allPanels <- unique(allData[,c("cueNum","signal")]) # Get all the panels
  dataPanels <- unique(allData[!is.na(allData$value),][,c("cueNum","signal")]) # Get only panels with data
  emptyPanels <- rbind(allPanels, dataPanels)
  emptyPanels <- emptyPanels[!(duplicated(emptyPanels) | duplicated(emptyPanels, fromLast = T)),] # Remove duplicates, leaving only panels without data
  
  # Remove empty values from data
  data1 <- data1[!(is.na(data1$value)),]
  data2 <- data2[!(is.na(data2$value)),]
  
  # If there are empty panels, add empty values to them so they will still be drawn
  if (nrow(emptyPanels) > 0) {
    emptyPanels[,c("variance", "value", "time")] <- NA
    data1 <- rbind(data1, emptyPanels)
  }

  # Data plot
  dataPlot <- ggplot() + 
    # geom_tile(data=emptyPanels, aes(fill="green", x=x, y=y, height=hieght, ymax=ymax)) +
    geom_line(data=data1, aes(x=time, y=value)) +
    geom_point(data=data1, aes(x=time, y=value)) +
    geom_line(data=data2, aes(x=time, y=value), color="red") +
    geom_point(data=data2, aes(x=time, y=value), color="red") +
    # geom_errorbar(data=data, aes(ymin=value-sqrt(variance), ymax=value+sqrt(variance)), width=10) + # Error bars
    facet_grid(cols=vars(signal), rows=vars(cueNum)) + # This splits the graph into times and cues
    theme(strip.text.y = element_blank(), # Removes the facet labels on the y axis
          panel.border = element_rect(size=1, fill=NA, colour="black"), # Add borders
          plot.margin = unit(c(5.5,2.75,5.5,5.5), "pt"))
    
  # Cues plot
  cueColors <- c("None"="white", "Inhibitor"="red2", "Stimulus"="green3", "KO"="darkblue")
  cuesPlot <- ggplot(cuesGather, aes(x=.5, y=.5)) +
    facet_grid(cols=vars(cue), rows=vars(cueNum)) +
    geom_tile(aes(fill=value), colour="black", size=1) + # Create the tiles (colour and size affect borders)
    scale_fill_manual(values=cueColors, drop=FALSE) + # Color the tiles appropriately
    scale_x_continuous(limits=c(0,1), expand=c(0,0)) + scale_y_reverse(limits=c(1,0), expand=c(0,0)) + # Reverse the ordering and set proper scales
    theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), # Remove axis labels
          legend.position = "none", panel.background = element_blank(), strip.text.y = element_blank(), # Remove legend, background, and y labels
          # strip.background = element_blank(), strip.text.x = element_text(angle=75, vjust=1),
          plot.margin = unit(c(0,5.5,0,0), "pt"), plot.background = element_blank()) # Remove margins, these are set by data plot
  
  # If width wasn't provided, make a best guess for it
  if (is.na(dataWidth)) {
    widths = c(length(MIDASlist1$namesSignals), length(MIDASlist1$namesCues)/4)
  } else {
    widths = c(dataWidth, 1)
  }
  
  # Put them together and plot
  suppressWarnings(suppressMessages(plot_grid(dataPlot, cuesPlot, align="h", rel_widths = widths)))
}
